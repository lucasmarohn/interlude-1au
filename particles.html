<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Dust Particles</title>
    <style>
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: black;
            overflow: hidden;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
            z-index: 10;
            position: absolute;
            mix-blend-mode: screen;
            opacity: 0;
            animation: fadeIn .5s ease-in-out forwards;
            animation-delay: 3s;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            display: none;
        }

        .controls label {
            display: block;
            margin-bottom: 5px;
        }

        .controls input[type="range"] {
            width: 150px;
            margin-bottom: 10px;
        }

        .controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }

        .controls button:hover {
            background: #45a049;
        }

        .bg-video {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          object-fit: cover;
          z-index: 0;
          transition: transform 0.1s ease-out;
        }

        .bg-image {
            z-index: 1;
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            mix-blend-mode: screen;
            filter: contrast(1.2) grayscale(1);

        }

        

    </style>
</head>
<body>
    <canvas class="canvas particle" data-parallax="0.05"></canvas>
    <!-- <canvas class="canvas particle" data-parallax="0.07" style="filter: blur(10px)"></canvas> -->
    <canvas class="canvas sprite" data-parallax="0.025"></canvas>
    <video src="footage/0001-0600.mp4" muted autoplay playsInline class="bg-video"></video>


    <div class="controls">
        <label>Particle Count: <span id="countValue">200</span></label>
        <input type="range" id="particleCount" min="50" max="500" value="200">
        
        <label>Speed: <span id="speedValue">0.3</span></label>
        <input type="range" id="particleSpeed" min="0.05" max="1.5" step="0.05" value="0.3">
        
        <label>Size: <span id="sizeValue">0.8</span></label>
        <input type="range" id="particleSize" min="0.1" max="2.0" step="0.1" value="0.8">
        
        <label>Parallax: <span id="parallaxValue">0.05</span></label>
        <input type="range" id="parallaxIntensity" min="0" max="0.5" step="0.05" value="0.3">
        
        <label>Bokeh Count: <span id="bokehCountValue">15</span></label>
        <input type="range" id="bokehCount" min="5" max="30" value="15">
        
        <label>Bokeh Size: <span id="bokehSizeValue">1.5</span></label>
        <input type="range" id="bokehSize" min="0.5" max="3.0" step="0.1" value="1.5">
        
        <label>Video Skew: <span id="skewValue">0.1</span></label>
        <input type="range" id="videoSkew" min="0" max="0.5" step="0.01" value="0.1">
        
        <button onclick="resetParticles()">Reset</button>
        <button onclick="toggleAnimation()">Pause/Play</button>
    </div>


    <script>

        const speedMultiplier = 1

        class ParticleSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                
                // Configuration
                this.config = {
                    particleCount: 200,
                    speed: .25 * speedMultiplier,
                    size: 1,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 500,
                    zoom: 2.5,
                    parallaxIntensity: parseFloat(this.canvas.dataset.parallax) || 0.05,
                    videoSkewIntensity: 0,
                    maxLife: 200 // Maximum life span for regular particles
                };
                
                // Mouse tracking for parallax and video skew
                this.mouseX = 0;
                this.mouseY = 0;
                this.parallaxOffsetX = 0;
                this.parallaxOffsetY = 0;
                this.videoSkewX = 0;
                this.videoSkewY = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                this.setupUniformCreation();
                // Delay animation start to match CSS animation delay (10s) + fade duration (5s)
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
            }
            
            setupUniformCreation() {
                // Create regular particles at uniform intervals to maintain consistent distribution
                const interval = this.config.maxLife / this.config.particleCount;
                
                this.creationInterval = setInterval(() => {
                    // Always create a new particle to maintain count
                    this.particles.push(this.createParticle());
                }, interval);
            }
            
            setupEventListeners() {
                // Mouse tracking for parallax and video skew
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    // Calculate parallax offset based on mouse position relative to center
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    this.parallaxOffsetX = (this.mouseX - centerX) * this.config.parallaxIntensity;
                    this.parallaxOffsetY = (this.mouseY - centerY) * this.config.parallaxIntensity;
                    
                    // Calculate video skew based on mouse position relative to center
                    const normalizedX = (this.mouseX - centerX) / centerX; // -1 to 1
                    const normalizedY = (this.mouseY - centerY) / centerY; // -1 to 1
                    
                    this.videoSkewX = normalizedX * this.config.videoSkewIntensity;
                    this.videoSkewY = normalizedY * this.config.videoSkewIntensity;
                    
                });
                
                // Particle count control
                const countSlider = document.getElementById('particleCount');
                const countValue = document.getElementById('countValue');
                countSlider.addEventListener('input', (e) => {
                    this.config.particleCount = parseInt(e.target.value);
                    countValue.textContent = e.target.value;
                    this.createParticles();
                });
                
                // Speed control
                const speedSlider = document.getElementById('particleSpeed');
                const speedValue = document.getElementById('speedValue');
                speedSlider.addEventListener('input', (e) => {
                    this.config.speed = parseFloat(e.target.value);
                    speedValue.textContent = e.target.value;
                });
                
                // Size control
                const sizeSlider = document.getElementById('particleSize');
                const sizeValue = document.getElementById('sizeValue');
                sizeSlider.addEventListener('input', (e) => {
                    this.config.size = parseFloat(e.target.value);
                    sizeValue.textContent = e.target.value;
                });
                
                // Parallax control
                const parallaxSlider = document.getElementById('parallaxIntensity');
                const parallaxValue = document.getElementById('parallaxValue');
                parallaxSlider.addEventListener('input', (e) => {
                    this.config.parallaxIntensity = parseFloat(e.target.value);
                    parallaxValue.textContent = e.target.value;
                });
                
                // Video skew control
                const skewSlider = document.getElementById('videoSkew');
                const skewValue = document.getElementById('skewValue');
                skewSlider.addEventListener('input', (e) => {
                    this.config.videoSkewIntensity = parseFloat(e.target.value);
                    skewValue.textContent = e.target.value;
                });
                
            }
            
            createParticles() {
                // Start with empty array - particles will be created uniformly over time
                this.particles = [];
            }
            
            createParticle() {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed;
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    life: 1.0,
                    maxLife: Math.random() * 200 + 200
                };
            }
            
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight acceleration
                    particle.vx *= .9999;
                    particle.vy *= .9999;
                    
                    // Update life
                    particle.life -= 1 / particle.maxLife;
                    
                    // Start at 100% opacity and fade out
                    particle.opacity = Math.max(0, Math.min(1, particle.life));
                    
                    // Size starts at 0 and grows to maximum by end of life
                    // Ensure size is always finite and positive
                    const sizeMultiplier = Math.max(0, Math.min(1, 1 - particle.life));
                    particle.currentSize = Math.max(0, particle.size * sizeMultiplier);
                    
                    // Only remove dead particles, let them move past the edge
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                        // Don't immediately replace - let uniform creation handle it
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and parallax transformations
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Apply parallax offset
                this.ctx.translate(this.parallaxOffsetX, this.parallaxOffsetY);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Create glow effect only if particle has size
                    if (particle.currentSize > 0) {
                        const gradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.currentSize * 3
                        );
                        gradient.addColorStop(0, `hsla(${200 + particle.life * 60}, 70%, ${70 + particle.life * 20}%, ${particle.opacity})`);
                        gradient.addColorStop(0.5, `hsla(${200 + particle.life * 60}, 70%, ${50 + particle.life * 30}%, ${particle.opacity * 0.5})`);
                        gradient.addColorStop(1, `hsla(${200 + particle.life * 60}, 70%, ${30 + particle.life * 20}%, 0)`);
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.currentSize * 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Draw core particle only if it has size
                    if (particle.currentSize > 0) {
                        this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.currentSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
        }

        class ParticleSpriteSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement;
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                this.spriteImages = [];
                this.spriteImageSources = ['debris1.png', 'debris2.png','debris3.png'];
                
                // Configuration
                this.config = {
                    particleCount: 500,
                    speed: 2 * speedMultiplier,
                    size: 1,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 500,
                    zoom: 2.5,
                    parallaxIntensity: parseFloat(this.canvas.dataset.parallax) || 0.05,
                    videoSkewIntensity: 0.05,
                    spriteSize: 20, // Size of the sprite image
                    rotationSpeed: 0.02, // How fast particles rotate
                    maxLife: 1000 // Maximum life span for sprites
                };
                
                // Mouse tracking for parallax and video skew
                this.mouseX = 0;
                this.mouseY = 0;
                this.parallaxOffsetX = 0;
                this.parallaxOffsetY = 0;
                this.videoSkewX = 0;
                this.videoSkewY = 0;
                
                this.loadSprites();
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                this.setupUniformCreation();
                this.animate();
            }
            
            loadSprites() {
                let loadedCount = 0;
                const totalImages = this.spriteImageSources.length;
                
                this.spriteImageSources.forEach((src, index) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedCount++;
                        console.log(`Sprite image ${index + 1} loaded successfully: ${src}`);
                        if (loadedCount === totalImages) {
                            console.log('All sprite images loaded successfully');
                        }
                    };
                    img.onerror = () => {
                        console.error(`Failed to load sprite image: ${src}`);
                    };
                    img.src = src;
                    this.spriteImages.push(img);
                });
            }
            
            setupUniformCreation() {
                // Create sprites at uniform intervals to maintain consistent distribution
                const interval = this.config.maxLife / this.config.particleCount;
                
                this.creationInterval = setInterval(() => {
                    // Always create a new particle to maintain count
                    this.particles.push(this.createParticle());
                }, interval);
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
            }
            
            setupEventListeners() {
                // Mouse tracking for parallax and video skew
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    // Calculate parallax offset based on mouse position relative to center
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    this.parallaxOffsetX = (this.mouseX - centerX) * this.config.parallaxIntensity;
                    this.parallaxOffsetY = (this.mouseY - centerY) * this.config.parallaxIntensity;
                    
                });
                
                // Particle count control
                const countSlider = document.getElementById('particleCount');
                const countValue = document.getElementById('countValue');
                if (countSlider) {
                    countSlider.addEventListener('input', (e) => {
                        this.config.particleCount = parseInt(e.target.value);
                        countValue.textContent = e.target.value;
                        this.createParticles();
                    });
                }
                
                // Speed control
                const speedSlider = document.getElementById('particleSpeed');
                const speedValue = document.getElementById('speedValue');
                if (speedSlider) {
                    speedSlider.addEventListener('input', (e) => {
                        this.config.speed = parseFloat(e.target.value);
                        speedValue.textContent = e.target.value;
                    });
                }
                
                // Size control
                const sizeSlider = document.getElementById('particleSize');
                const sizeValue = document.getElementById('sizeValue');
                if (sizeSlider) {
                    sizeSlider.addEventListener('input', (e) => {
                        this.config.size = parseFloat(e.target.value);
                        sizeValue.textContent = e.target.value;
                    });
                }
                
                // Parallax control
                const parallaxSlider = document.getElementById('parallaxIntensity');
                const parallaxValue = document.getElementById('parallaxValue');
                if (parallaxSlider) {
                    parallaxSlider.addEventListener('input', (e) => {
                        this.config.parallaxIntensity = parseFloat(e.target.value);
                        parallaxValue.textContent = e.target.value;
                    });
                }
                
                // Video skew control
                const skewSlider = document.getElementById('videoSkew');
                const skewValue = document.getElementById('skewValue');
                if (skewSlider) {
                    skewSlider.addEventListener('input', (e) => {
                        this.config.videoSkewIntensity = parseFloat(e.target.value);
                        skewValue.textContent = e.target.value;
                    });
                }
            }
            
            createParticles() {
                // Start with empty array - particles will be created uniformly over time
                this.particles = [];
            }
            
            createParticle(index = 0) {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed;
                
                // Stagger particle creation to avoid waves
                const lifeOffset = (index / this.config.particleCount) * this.config.maxLife;
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    life: 1.0,
                    maxLife: this.config.maxLife,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * this.config.rotationSpeed,
                    spriteIndex: Math.floor(Math.random() * this.spriteImageSources.length),
                    creationTime: Date.now() + lifeOffset
                };
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Update rotation
                    particle.rotation += particle.rotationSpeed;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight friction
                    particle.vx *= .9999;
                    particle.vy *= .9999;
                    
                    // Update life
                    particle.life -= 1 / particle.maxLife;
                    
                    // Keep sprite opacity constant
                    particle.opacity = 1.0;
                    
                    // Size starts at 0 and grows to maximum by end of life
                    // Ensure size is always finite and positive
                    const sizeMultiplier = Math.max(0, Math.min(1, 1 - particle.life));
                    particle.currentSize = Math.max(0, particle.size * sizeMultiplier);
                    
                    // Only remove dead particles, let them move past the edge
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                        // Don't immediately replace - let uniform creation handle it
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and parallax transformations
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Apply parallax offset
                this.ctx.translate(this.parallaxOffsetX, this.parallaxOffsetY);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Move to particle position and rotate
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    // Draw sprite if loaded, otherwise draw a fallback circle
                    const spriteImage = this.spriteImages[particle.spriteIndex];
                    if (spriteImage && spriteImage.complete) {
                        const spriteSize = particle.currentSize * this.config.spriteSize;
                        this.ctx.drawImage(
                            spriteImage,
                            -spriteSize / 2, -spriteSize / 2,
                            spriteSize, spriteSize
                        );
                    } else {
                        // Fallback: draw a colored circle
                        this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.currentSize * 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
        }

        const canvases = document.querySelectorAll('canvas.particle')
        const sprites = document.querySelectorAll('canvas.sprite')
        
        canvases.forEach(canvasElement => {
            new ParticleSystem(canvasElement)
        })
        sprites.forEach(canvasElement => {
            new ParticleSpriteSystem(canvasElement)
        })

    
        
        
    </script>
</body>
</html>
