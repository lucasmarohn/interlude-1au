<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Dust Particles</title>
    <style>
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: black;
            overflow: hidden;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
            z-index: 10;
            position: absolute;
            mix-blend-mode: screen;
            opacity: 0;
            animation: fadeIn .5s ease-in-out forwards;
            animation-delay: 3s;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 14px;
            display: none;
        }

        .controls label {
            display: block;
            margin-bottom: 5px;
        }

        .controls input[type="range"] {
            width: 150px;
            margin-bottom: 10px;
        }

        .controls button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }

        .controls button:hover {
            background: #45a049;
        }

        .bg-video {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          object-fit: cover;
          z-index: 0;
        }

        .bg-image {
            z-index: 1;
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            mix-blend-mode: screen;
            filter: contrast(1.2) grayscale(1);

        }

        

    </style>
</head>
<body>
    <canvas class="canvas"></canvas>
    <canvas class="canvas" style="filter: blur(10px)"></canvas>
    <video src="footage/V10001-0250.mp4" muted autoplay playsInline class="bg-video"></video>


    <div class="controls">
        <label>Particle Count: <span id="countValue">200</span></label>
        <input type="range" id="particleCount" min="50" max="500" value="200">
        
        <label>Speed: <span id="speedValue">0.3</span></label>
        <input type="range" id="particleSpeed" min="0.05" max="1.5" step="0.05" value="0.3">
        
        <label>Size: <span id="sizeValue">0.8</span></label>
        <input type="range" id="particleSize" min="0.1" max="2.0" step="0.1" value="0.8">
        
        <label>Parallax: <span id="parallaxValue">0.05</span></label>
        <input type="range" id="parallaxIntensity" min="0" max="0.5" step="0.05" value="0.3">
        
        <label>Bokeh Count: <span id="bokehCountValue">15</span></label>
        <input type="range" id="bokehCount" min="5" max="30" value="15">
        
        <label>Bokeh Size: <span id="bokehSizeValue">1.5</span></label>
        <input type="range" id="bokehSize" min="0.5" max="3.0" step="0.1" value="1.5">
        
        <button onclick="resetParticles()">Reset</button>
        <button onclick="toggleAnimation()">Pause/Play</button>
    </div>


    <script>

        class ParticleSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                
                // Configuration
                this.config = {
                    particleCount: 200,
                    speed: 0.3,
                    size: 0.8,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 300,
                    zoom: 2.5,
                    parallaxIntensity: 0.05
                };
                
                // Mouse tracking for parallax
                this.mouseX = 0;
                this.mouseY = 0;
                this.parallaxOffsetX = 0;
                this.parallaxOffsetY = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                // Delay animation start to match CSS animation delay (10s) + fade duration (5s)
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
            }
            
            setupEventListeners() {
                // Mouse tracking for parallax
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    // Calculate parallax offset based on mouse position relative to center
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    this.parallaxOffsetX = (this.mouseX - centerX) * this.config.parallaxIntensity;
                    this.parallaxOffsetY = (this.mouseY - centerY) * this.config.parallaxIntensity;
                });
                
                // Particle count control
                const countSlider = document.getElementById('particleCount');
                const countValue = document.getElementById('countValue');
                countSlider.addEventListener('input', (e) => {
                    this.config.particleCount = parseInt(e.target.value);
                    countValue.textContent = e.target.value;
                    this.createParticles();
                });
                
                // Speed control
                const speedSlider = document.getElementById('particleSpeed');
                const speedValue = document.getElementById('speedValue');
                speedSlider.addEventListener('input', (e) => {
                    this.config.speed = parseFloat(e.target.value);
                    speedValue.textContent = e.target.value;
                });
                
                // Size control
                const sizeSlider = document.getElementById('particleSize');
                const sizeValue = document.getElementById('sizeValue');
                sizeSlider.addEventListener('input', (e) => {
                    this.config.size = parseFloat(e.target.value);
                    sizeValue.textContent = e.target.value;
                });
                
                // Parallax control
                const parallaxSlider = document.getElementById('parallaxIntensity');
                const parallaxValue = document.getElementById('parallaxValue');
                parallaxSlider.addEventListener('input', (e) => {
                    this.config.parallaxIntensity = parseFloat(e.target.value);
                    parallaxValue.textContent = e.target.value;
                });
                
            }
            
            createParticles() {
                this.particles = [];
                for (let i = 0; i < this.config.particleCount; i++) {
                    this.particles.push(this.createParticle());
                }
            }
            
            createParticle() {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed;
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: Math.random() * 0.8 + 0.2,
                    life: 1.0,
                    maxLife: Math.random() * 200 + 200
                };
            }
            
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight friction
                    particle.vx *= 0.999;
                    particle.vy *= 0.999;
                    
                    // Update life
                    particle.life -= 1 / particle.maxLife;
                    
                    // Calculate distance from center for opacity
                    const distanceFromCenter = Math.sqrt(
                        Math.pow(particle.x - this.config.centerX, 2) + 
                        Math.pow(particle.y - this.config.centerY, 2)
                    );
                    
                    // Fade based on distance
                    const distanceOpacity = Math.max(0, 1 - distanceFromCenter / this.config.fadeDistance);
                    
                    // Create fade in/fade out effect based on life
                    let lifeOpacity;
                    if (particle.life > 0.5) {
                        // First half: fade in (0 to 1)
                        lifeOpacity = (1 - particle.life) * 2;
                    } else {
                        // Second half: fade out (1 to 0)
                        lifeOpacity = particle.life * 2;
                    }
                    
                    particle.opacity = distanceOpacity * lifeOpacity;
                    
                    // Remove dead particles or particles that are too far off screen
                    const maxDistance = Math.sqrt(
                        Math.pow(this.canvas.width, 2) + 
                        Math.pow(this.canvas.height, 2)
                    );
                    
                    if (particle.life <= 0 || particle.opacity <= 0 || distanceFromCenter > maxDistance) {
                        this.particles.splice(i, 1);
                        // Replace with new particle to maintain count
                        this.particles.push(this.createParticle());
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and parallax transformations
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Apply parallax offset
                this.ctx.translate(this.parallaxOffsetX, this.parallaxOffsetY);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Create glow effect
                    const gradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    gradient.addColorStop(0, `hsla(${200 + particle.life * 60}, 70%, ${70 + particle.life * 20}%, ${particle.opacity})`);
                    gradient.addColorStop(0.5, `hsla(${200 + particle.life * 60}, 70%, ${50 + particle.life * 30}%, ${particle.opacity * 0.5})`);
                    gradient.addColorStop(1, `hsla(${200 + particle.life * 60}, 70%, ${30 + particle.life * 20}%, 0)`);
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw core particle
                    this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
        }
        

        const canvases = document.querySelectorAll('canvas')
        
        canvases.forEach(canvasElement => {
            new ParticleSystem(canvasElement)
        })

    
        
        
    </script>
</body>
</html>
