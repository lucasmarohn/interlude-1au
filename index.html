<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Dust Particles</title>
    <style>
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeInImages {
            from {
                opacity: 0;
            }
            to {
                opacity: .3;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: black;
            overflow: hidden;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
            z-index: 10;
            position: absolute;
            mix-blend-mode: screen;
            opacity: 0;
            animation: fadeIn .5s ease-in-out forwards;
            animation-delay: 3s;
        }

        .bg-video {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          object-fit: cover;
          z-index: 0;
          transition: transform 0.1s ease-out;
        }

        .bg-images {
            display: block;
            z-index: 100;
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fadeInImages .5s ease-in-out forwards;
            animation-delay: 3s; 
            mix-blend-mode: color-dodge;

        }

        .bg-image {
            z-index: 1;
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: .5;
            animation: rotate360 30s linear infinite;
            mix-blend-mode: screen;
        }
        .bg-image.slow {
            animation: rotate3602 50s linear infinite !important;
            mix-blend-mode: screen;

        }

        @keyframes rotate360 {
            from {
                transform: rotate(0)
            }
            to {
                transform: rotate(360deg)
            }
        }
        @keyframes rotate3602 {
            from {
                transform: rotate(30)
            }
            to {
                transform: rotate(400deg)
            }
        }

        

    </style>
</head>
<body>
    <canvas class="canvas particle" data-parallax="0.05"></canvas>
    <!-- <canvas class="canvas particle" data-parallax="0.07" style="filter: blur(10px)"></canvas> -->
    <canvas class="canvas sprite" data-parallax="0.025"></canvas>
    <video src="http://cdn.prod.website-files.com/5ff3b5564c41048449a189b2%2F68c1a67ef8cee1a64073b0f4_sept09-0001-0660_small-transcode.mp4" muted autoplay playsInline class="bg-video"></video>
    <div class="bg-images">
        <img src="radial-blur.png" class="bg-image">
        <img src="radial-blur.png" class="bg-image slow">
    </div>


    


    <script>
        const spriteImageSources = ['sprites/1.png', 'sprites/2.png','sprites/3.png','sprites/4.png','sprites/5.png']
        const spriteSize = 1;
        const speedMultiplier = 1

        // Detect if device supports touch
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }

        class ParticleSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                
                // Configuration
                this.config = {
                    particleCount: 200,
                    speed: 0.25 * speedMultiplier, // Base speed - will be adjusted for viewport
                    size: 1,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 500,
                    zoom: 2.5,
                    parallaxIntensity: isTouchDevice() ? 0 : (parseFloat(this.canvas.dataset.parallax) || 0.05),
                    videoSkewIntensity: 0,
                    maxLife: 200 // Maximum life span for regular particles
                };
                
                // Mouse tracking for parallax and video skew
                this.mouseX = 0;
                this.mouseY = 0;
                this.parallaxOffsetX = 0;
                this.parallaxOffsetY = 0;
                this.videoSkewX = 0;
                this.videoSkewY = 0;
                
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                this.setupUniformCreation();
                // Delay animation start to match CSS animation delay (10s) + fade duration (5s)
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                
                // Adjust speed for viewport size to maintain consistent visual speed
                // Use diagonal of viewport as reference for consistent speed across devices
                const viewportDiagonal = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                const referenceDiagonal = Math.sqrt(1920 * 1920 + 1080 * 1080); // Desktop reference
                this.config.viewportSpeedMultiplier = viewportDiagonal / referenceDiagonal;
                
                // Adjust particle count for viewport size - fewer on small devices, same on large devices
                const baseParticleCount = 200; // Original desktop count
                const viewportArea = this.canvas.width * this.canvas.height;
                const referenceArea = 1920 * 1080; // Desktop reference area
                const areaRatio = viewportArea / referenceArea;
                
                // Scale particle count with area, but cap at original count for large screens
                this.config.particleCount = Math.min(baseParticleCount, Math.round(baseParticleCount * areaRatio));
            }
            
            setupUniformCreation() {
                // Create regular particles at uniform intervals to maintain consistent distribution
                // Estimate natural life based on viewport size and particle speed
                const estimatedNaturalLife = Math.max(this.canvas.width, this.canvas.height) / this.config.speed;
                const interval = estimatedNaturalLife / this.config.particleCount;
                
                this.creationInterval = setInterval(() => {
                    // Always create a new particle to maintain count
                    this.particles.push(this.createParticle());
                }, interval);
            }
            
            setupEventListeners() {
                // Mouse tracking for parallax and video skew
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    // Calculate parallax offset based on mouse position relative to center
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    this.parallaxOffsetX = (this.mouseX - centerX) * this.config.parallaxIntensity;
                    this.parallaxOffsetY = (this.mouseY - centerY) * this.config.parallaxIntensity;
                    
                });
                
                // Particle count control
                this.createParticles();
                
            }
            
            createParticles() {
                // Start with empty array - particles will be created uniformly over time
                this.particles = [];
            }
            
            createParticle() {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                // Apply viewport speed multiplier for consistent visual speed across devices
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed * (this.config.viewportSpeedMultiplier || 1);
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: 1.0,
                    age: 0
                };
            }
            
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight acceleration
                    particle.vx *= .9995;
                    particle.vy *= .9995;
                    
                    // Calculate distance from center for fade effect
                    const dx = particle.x - this.config.centerX;
                    const dy = particle.y - this.config.centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Fade out based on distance from center
                    const maxVisibleDistance = this.config.maxDistance * 0.8; // Start fading at 80% of max distance
                    const fadeStart = maxVisibleDistance * 0.6; // Start fading at 60% of max distance
                    
                    if (distance > fadeStart) {
                        const fadeProgress = Math.min(1, (distance - fadeStart) / (maxVisibleDistance - fadeStart));
                        particle.opacity = Math.max(0, 1 - fadeProgress);
                    } else {
                        particle.opacity = 1;
                    }
                    
                    // Size grows over time (not based on life)
                    particle.age = (particle.age || 0) + 1;
                    const maxAge = 300; // Particles reach full size after 300 frames
                    const sizeMultiplier = Math.min(1, particle.age / maxAge);
                    particle.currentSize = particle.size * sizeMultiplier;
                    
                    // Remove particles that are completely outside viewport
                    const margin = 100; // Extra margin to ensure smooth removal
                    if (particle.x < -margin || 
                        particle.x > this.canvas.width + margin || 
                        particle.y < -margin || 
                        particle.y > this.canvas.height + margin ||
                        distance > this.config.maxDistance * 1.2) { // Remove at 120% of max distance
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and parallax transformations
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Apply parallax offset
                this.ctx.translate(this.parallaxOffsetX, this.parallaxOffsetY);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Create glow effect only if particle has size
                    if (particle.currentSize > 0) {
                        const gradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.currentSize * 3
                        );
                        gradient.addColorStop(0, `hsla(${200 + particle.life * 60}, 70%, ${70 + particle.life * 20}%, ${particle.opacity})`);
                        gradient.addColorStop(0.5, `hsla(${200 + particle.life * 60}, 70%, ${50 + particle.life * 30}%, ${particle.opacity * 0.5})`);
                        gradient.addColorStop(1, `hsla(${200 + particle.life * 60}, 70%, ${30 + particle.life * 20}%, 0)`);
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.currentSize * 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Draw core particle only if it has size
                    if (particle.currentSize > 0) {
                        this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.currentSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
        }

        class ParticleSpriteSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement;
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                this.spriteImages = [];
                this.spriteImageSources = spriteImageSources;
                
                // Configuration
                this.config = {
                    particleCount: 500,
                    speed: 2 * speedMultiplier,
                    size: spriteSize,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 500,
                    zoom: 2.5,
                    parallaxIntensity: isTouchDevice() ? 0 : (parseFloat(this.canvas.dataset.parallax) || 0.05),
                    videoSkewIntensity: 0.05,
                    spriteSize: 20, // Size of the sprite image
                    rotationSpeed: 0.02, // How fast particles rotate
                    maxLife: 1000 // Maximum life span for sprites
                };
                
                // Mouse tracking for parallax and video skew
                this.mouseX = 0;
                this.mouseY = 0;
                this.parallaxOffsetX = 0;
                this.parallaxOffsetY = 0;
                this.videoSkewX = 0;
                this.videoSkewY = 0;
                
                this.loadSprites();
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                this.setupUniformCreation();
                this.animate();
            }
            
            loadSprites() {
                let loadedCount = 0;
                const totalImages = this.spriteImageSources.length;
                
                this.spriteImageSources.forEach((src, index) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedCount++;
                        console.log(`Sprite image ${index + 1} loaded successfully: ${src}`);
                        if (loadedCount === totalImages) {
                            console.log('All sprite images loaded successfully');
                        }
                    };
                    img.onerror = () => {
                        console.error(`Failed to load sprite image: ${src}`);
                    };
                    img.src = src;
                    this.spriteImages.push(img);
                });
            }
            
            setupUniformCreation() {
                // Create sprites at uniform intervals to maintain consistent distribution
                // Estimate natural life based on viewport size and particle speed
                const estimatedNaturalLife = Math.max(this.canvas.width, this.canvas.height) / this.config.speed;
                const interval = estimatedNaturalLife / this.config.particleCount;
                
                this.creationInterval = setInterval(() => {
                    // Always create a new particle to maintain count
                    this.particles.push(this.createParticle());
                }, interval);
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                
                // Adjust speed for viewport size to maintain consistent visual speed
                // Use diagonal of viewport as reference for consistent speed across devices
                const viewportDiagonal = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                const referenceDiagonal = Math.sqrt(1920 * 1920 + 1080 * 1080); // Desktop reference
                this.config.viewportSpeedMultiplier = viewportDiagonal / referenceDiagonal;
                
                // Adjust particle count for viewport size - fewer on small devices, same on large devices
                const baseParticleCount = 500; // Original desktop count for sprites
                const viewportArea = this.canvas.width * this.canvas.height;
                const referenceArea = 1920 * 1080; // Desktop reference area
                const areaRatio = viewportArea / referenceArea;
                
                // Scale particle count with area, but cap at original count for large screens
                this.config.particleCount = Math.min(baseParticleCount, Math.round(baseParticleCount * areaRatio));
            }
            
            setupEventListeners() {
                // Mouse tracking for parallax and video skew
                document.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                    
                    // Calculate parallax offset based on mouse position relative to center
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    
                    this.parallaxOffsetX = (this.mouseX - centerX) * this.config.parallaxIntensity;
                    this.parallaxOffsetY = (this.mouseY - centerY) * this.config.parallaxIntensity;
                    
                });
                
                this.createParticles();
            }
            
            createParticles() {
                // Start with empty array - particles will be created uniformly over time
                this.particles = [];
            }
            
            createParticle(index = 0) {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                // Apply viewport speed multiplier for consistent visual speed across devices
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed * (this.config.viewportSpeedMultiplier || 1);
                
                // Stagger particle creation to avoid waves
                const staggerOffset = (index / this.config.particleCount) * 100; // Small stagger for variety
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: 1.0,
                    age: 0,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * this.config.rotationSpeed,
                    spriteIndex: Math.floor(Math.random() * this.spriteImageSources.length)
                };
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Update rotation
                    particle.rotation += particle.rotationSpeed;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight friction
                    particle.vx *= .9995;
                    particle.vy *= .9995;
                    
                    // Calculate distance from center for fade effect
                    const dx = particle.x - this.config.centerX;
                    const dy = particle.y - this.config.centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Fade out based on distance from center
                    const maxVisibleDistance = this.config.maxDistance * 0.8; // Start fading at 80% of max distance
                    const fadeStart = maxVisibleDistance * 0.6; // Start fading at 60% of max distance
                    
                    if (distance > fadeStart) {
                        const fadeProgress = Math.min(1, (distance - fadeStart) / (maxVisibleDistance - fadeStart));
                        particle.opacity = Math.max(0, 1 - fadeProgress);
                    } else {
                        particle.opacity = 1.0;
                    }
                    
                    // Size grows over time (not based on life)
                    particle.age = (particle.age || 0) + 1;
                    const maxAge = 300; // Sprites reach full size after 300 frames
                    const sizeMultiplier = Math.min(1, particle.age / maxAge);
                    particle.currentSize = particle.size * sizeMultiplier;
                    
                    // Remove particles that are completely outside viewport
                    const margin = 100; // Extra margin to ensure smooth removal
                    if (particle.x < -margin || 
                        particle.x > this.canvas.width + margin || 
                        particle.y < -margin || 
                        particle.y > this.canvas.height + margin ||
                        distance > this.config.maxDistance * 1.2) { // Remove at 120% of max distance
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom and parallax transformations
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Apply parallax offset
                this.ctx.translate(this.parallaxOffsetX, this.parallaxOffsetY);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Move to particle position and rotate
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    // Draw sprite if loaded, otherwise draw a fallback circle
                    const spriteImage = this.spriteImages[particle.spriteIndex];
                    if (spriteImage && spriteImage.complete) {
                        const spriteSize = particle.currentSize * this.config.spriteSize;
                        this.ctx.drawImage(
                            spriteImage,
                            -spriteSize / 2, -spriteSize / 2,
                            spriteSize, spriteSize
                        );
                    } else {
                        // Fallback: draw a colored circle
                        this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.currentSize * 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
        }

        const canvases = document.querySelectorAll('canvas.particle')
        const sprites = document.querySelectorAll('canvas.sprite')
        
        canvases.forEach(canvasElement => {
            new ParticleSystem(canvasElement)
        })
        sprites.forEach(canvasElement => {
            new ParticleSpriteSystem(canvasElement)
        })

        // Video parallax system
        class VideoParallaxSystem {
            constructor() {
                this.video = document.querySelector('.bg-video');
                this.parallaxIntensity = isTouchDevice() ? 0 : 0.005; // Disable parallax on touch devices
                this.setupVideoParallax();
            }
            
            setupVideoParallax() {
                if (!this.video || isTouchDevice()) return; // Skip setup on touch devices
                
                document.addEventListener('mousemove', (e) => {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Calculate parallax offset based on mouse position relative to center
                    const parallaxX = (e.clientX - centerX) * this.parallaxIntensity;
                    const parallaxY = (e.clientY - centerY) * this.parallaxIntensity;
                    
                    // Apply parallax to video with scale to account for fullscreen movement
                    this.video.style.transform = `scale(1.05) translate(${parallaxX}px, ${parallaxY}px)`;
                });
            }
        }
        
        // Initialize video parallax system
        new VideoParallaxSystem();
        
    </script>
</body>
</html>
