<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Dust Particles</title>
    <style>
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeInImages {
            from {
                opacity: 0;
            }
            to {
                opacity: .3;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: black;
            overflow: hidden;
            height: 100vh;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
            cursor: crosshair;
            z-index: 10;
            position: absolute;
            mix-blend-mode: screen;
            opacity: 0;
            animation: fadeIn .5s ease-in-out forwards;
            animation-delay: 3s;
        }

        .bg-video {
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          object-fit: cover;
          z-index: 0;
          transition: transform 0.1s ease-out;
        }

        .bg-images {
            display: block;
            z-index: 100;
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            animation: fadeInImages .5s ease-in-out forwards;
            animation-delay: 3s; 
            mix-blend-mode: color-dodge;
            pointer-events: none;
        }

        .bg-image {
            z-index: 1;
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: .5;
            animation: rotate360 30s linear infinite;
            mix-blend-mode: screen;
        }
        .bg-image.slow {
            animation: rotate3602 50s linear infinite !important;
            mix-blend-mode: screen;

        }

        @keyframes rotate360 {
            from {
                transform: rotate(0)
            }
            to {
                transform: rotate(360deg)
            }
        }
        @keyframes rotate3602 {
            from {
                transform: rotate(30)
            }
            to {
                transform: rotate(400deg)
            }
        }
        [data-parallax] {
            transition: transform ease-out 1s;
        }

        

    </style>
</head>
<body>
    <canvas class="canvas particle" data-parallax="3"></canvas>
    <!-- <canvas class="canvas particle" data-parallax="0.07" style="filter: blur(10px)"></canvas> -->
    <canvas class="canvas sprite" data-parallax="2"></canvas>
    <video src="http://cdn.prod.website-files.com/5ff3b5564c41048449a189b2%2F68c1a67ef8cee1a64073b0f4_sept09-0001-0660_small-transcode.mp4" data-parallax="1" muted autoplay playsInline class="bg-video"></video>
    <div class="bg-images">
        <img src="radial-blur.png" class="bg-image">
        <img src="radial-blur.png" class="bg-image slow">
    </div>


    


    <script>
        const spriteImageSources = ['sprites/1.png', 'sprites/2.png','sprites/3.png','sprites/4.png','sprites/5.png']
        const spriteSize = 1;
        const speedMultiplier = 1

        // Detect if device supports touch
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }

        class ParticleSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                
                // Configuration
                this.config = {
                    particleCount: 200,
                    speed: 0.25 * speedMultiplier, // Base speed - will be adjusted for viewport
                    size: 1,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 500,
                    zoom: 2.5,
                    maxLife: 200 // Maximum life span for regular particles
                };
                
                // Force system for click/tap interactions
                this.forces = [];
                this.forceRadius = 150; // Radius of force effect
                this.forceStrength = isTouchDevice() ? 0.025 : 0.25; // Strength of the force
                this.forceDuration = 60; // Duration in frames (1 second at 60fps)
                
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                this.setupUniformCreation();
                // Delay animation start to match CSS animation delay (10s) + fade duration (5s)
                this.animate();
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                
                // Adjust speed for viewport size to maintain consistent visual speed
                // Use diagonal of viewport as reference for consistent speed across devices
                const viewportDiagonal = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                const referenceDiagonal = Math.sqrt(1920 * 1920 + 1080 * 1080); // Desktop reference
                this.config.viewportSpeedMultiplier = viewportDiagonal / referenceDiagonal;
                
                // Adjust particle count for viewport size - fewer on small devices, same on large devices
                const baseParticleCount = 200; // Original desktop count
                const viewportArea = this.canvas.width * this.canvas.height;
                const referenceArea = 1920 * 1080; // Desktop reference area
                const areaRatio = viewportArea / referenceArea;
                
                // Scale particle count with area, but cap at original count for large screens
                this.config.particleCount = Math.min(baseParticleCount, Math.round(baseParticleCount * areaRatio));
            }
            
            setupUniformCreation() {
                // Create regular particles at uniform intervals to maintain consistent distribution
                // Estimate natural life based on viewport size and particle speed
                const estimatedNaturalLife = Math.max(this.canvas.width, this.canvas.height) / this.config.speed;
                const interval = estimatedNaturalLife / this.config.particleCount;
                
                this.creationInterval = setInterval(() => {
                    // Always create a new particle to maintain count
                    this.particles.push(this.createParticle());
                }, interval);
            }
            
            setupEventListeners() {
                // Particle count control
                this.createParticles();
            }
            
            createParticles() {
                // Start with empty array - particles will be created uniformly over time
                this.particles = [];
            }
            
            createParticle() {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                // Apply viewport speed multiplier for consistent visual speed across devices
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed * (this.config.viewportSpeedMultiplier || 1);
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: 1.0,
                    age: 0
                };
            }
            
            
            updateParticles() {
                // Update forces first
                this.updateForces();
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Apply forces to particle velocity
                    this.forces.forEach(force => {
                        const dx = particle.x - force.x;
                        const dy = particle.y - force.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.forceRadius && distance > 0) {
                            // Calculate force strength based on distance and age
                            const normalizedDistance = distance / this.forceRadius;
                            const ageFactor = 1 - (force.age / force.maxAge);
                            const forceMagnitude = this.forceStrength * ageFactor * (1 - normalizedDistance);
                            
                            // Apply repulsive force
                            const forceX = (dx / distance) * forceMagnitude;
                            const forceY = (dy / distance) * forceMagnitude;
                            
                            particle.vx += forceX;
                            particle.vy += forceY;
                        }
                    });
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight acceleration
                    particle.vx *= .9995;
                    particle.vy *= .9995;
                    
                    // Calculate distance from center for fade effect
                    const dx = particle.x - this.config.centerX;
                    const dy = particle.y - this.config.centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Fade out based on distance from center
                    const maxVisibleDistance = this.config.maxDistance * 0.8; // Start fading at 80% of max distance
                    const fadeStart = maxVisibleDistance * 0.6; // Start fading at 60% of max distance
                    
                    if (distance > fadeStart) {
                        const fadeProgress = Math.min(1, (distance - fadeStart) / (maxVisibleDistance - fadeStart));
                        particle.opacity = Math.max(0, 1 - fadeProgress);
                    } else {
                        particle.opacity = 1;
                    }
                    
                    // Size grows over time (not based on life)
                    particle.age = (particle.age || 0) + 1;
                    const maxAge = 300; // Particles reach full size after 300 frames
                    const sizeMultiplier = Math.min(1, particle.age / maxAge);
                    particle.currentSize = particle.size * sizeMultiplier;
                    
                    // Remove particles that are completely outside viewport
                    const margin = 100; // Extra margin to ensure smooth removal
                    if (particle.x < -margin || 
                        particle.x > this.canvas.width + margin || 
                        particle.y < -margin || 
                        particle.y > this.canvas.height + margin ||
                        distance > this.config.maxDistance * 1.2) { // Remove at 120% of max distance
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom transformation
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Create glow effect only if particle has size
                    if (particle.currentSize > 0) {
                        const gradient = this.ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.currentSize * 3
                        );
                        gradient.addColorStop(0, `hsla(${200 + particle.life * 60}, 70%, ${70 + particle.life * 20}%, ${particle.opacity})`);
                        gradient.addColorStop(0.5, `hsla(${200 + particle.life * 60}, 70%, ${50 + particle.life * 30}%, ${particle.opacity * 0.5})`);
                        gradient.addColorStop(1, `hsla(${200 + particle.life * 60}, 70%, ${30 + particle.life * 20}%, 0)`);
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.currentSize * 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Draw core particle only if it has size
                    if (particle.currentSize > 0) {
                        this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.currentSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
            
            // Add a force at the specified position
            addForce(x, y) {
                // Transform click coordinates to match particle coordinate system
                // Reverse the zoom transformation applied in drawParticles
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const transformedX = (x - centerX) / this.config.zoom + centerX;
                const transformedY = (y - centerY) / this.config.zoom + centerY;
                
                console.log('ParticleSystem: Adding force:', x, y, '-> transformed:', transformedX, transformedY, 'Current forces:', this.forces.length);
                this.forces.push({
                    x: transformedX,
                    y: transformedY,
                    age: 0,
                    maxAge: this.forceDuration
                });
                console.log('ParticleSystem: Force added. Total forces:', this.forces.length);
            }
            
            // Update forces and remove expired ones
            updateForces() {
                for (let i = this.forces.length - 1; i >= 0; i--) {
                    const force = this.forces[i];
                    force.age++;
                    
                    if (force.age >= force.maxAge) {
                        this.forces.splice(i, 1);
                    }
                }
            }
        }

        class ParticleSpriteSystem {
            constructor(canvasElement) {
                this.canvas = canvasElement;
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.isAnimating = true;
                this.spriteImages = [];
                this.spriteImageSources = spriteImageSources;
                
                // Configuration
                this.config = {
                    particleCount: 500,
                    speed: 2 * speedMultiplier,
                    size: spriteSize,
                    centerX: 0,
                    centerY: 0,
                    maxDistance: 0,
                    fadeDistance: 500,
                    zoom: 2.5,
                    spriteSize: 20, // Size of the sprite image
                    rotationSpeed: 0.02, // How fast particles rotate
                    maxLife: 1000 // Maximum life span for sprites
                };
                
                // Force system for click/tap interactions
                this.forces = [];
                this.forceRadius = 150; // Radius of force effect
                this.forceStrength = isTouchDevice() ? 0.025 : 0.25; // Strength of the force
                this.forceDuration = 60; // Duration in frames (1 second at 60fps)
                
                this.loadSprites();
                this.setupCanvas();
                this.setupEventListeners();
                this.createParticles();
                this.setupUniformCreation();
                this.animate();
            }
            
            loadSprites() {
                let loadedCount = 0;
                const totalImages = this.spriteImageSources.length;
                
                this.spriteImageSources.forEach((src, index) => {
                    const img = new Image();
                    img.onload = () => {
                        loadedCount++;
                        console.log(`Sprite image ${index + 1} loaded successfully: ${src}`);
                        if (loadedCount === totalImages) {
                            console.log('All sprite images loaded successfully');
                        }
                    };
                    img.onerror = () => {
                        console.error(`Failed to load sprite image: ${src}`);
                    };
                    img.src = src;
                    this.spriteImages.push(img);
                });
            }
            
            setupUniformCreation() {
                // Create sprites at uniform intervals to maintain consistent distribution
                // Estimate natural life based on viewport size and particle speed
                const estimatedNaturalLife = Math.max(this.canvas.width, this.canvas.height) / this.config.speed;
                const interval = estimatedNaturalLife / this.config.particleCount;
                
                this.creationInterval = setInterval(() => {
                    // Always create a new particle to maintain count
                    this.particles.push(this.createParticle());
                }, interval);
            }
            
            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.config.centerX = this.canvas.width / 2;
                this.config.centerY = this.canvas.height / 2;
                this.config.maxDistance = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                
                // Adjust speed for viewport size to maintain consistent visual speed
                // Use diagonal of viewport as reference for consistent speed across devices
                const viewportDiagonal = Math.sqrt(
                    Math.pow(this.canvas.width, 2) + 
                    Math.pow(this.canvas.height, 2)
                );
                const referenceDiagonal = Math.sqrt(1920 * 1920 + 1080 * 1080); // Desktop reference
                this.config.viewportSpeedMultiplier = viewportDiagonal / referenceDiagonal;
                
                // Adjust particle count for viewport size - fewer on small devices, same on large devices
                const baseParticleCount = 500; // Original desktop count for sprites
                const viewportArea = this.canvas.width * this.canvas.height;
                const referenceArea = 1920 * 1080; // Desktop reference area
                const areaRatio = viewportArea / referenceArea;
                
                // Scale particle count with area, but cap at original count for large screens
                this.config.particleCount = Math.min(baseParticleCount, Math.round(baseParticleCount * areaRatio));
            }
            
            setupEventListeners() {
                this.createParticles();
            }
            
            createParticles() {
                // Start with empty array - particles will be created uniformly over time
                this.particles = [];
            }
            
            createParticle(index = 0) {
                const angle = Math.random() * Math.PI * 2;
                // Create emission area that's 3x larger (180% of canvas dimensions)
                const emissionRadiusX = (this.canvas.width * 1) / 2;
                const emissionRadiusY = (this.canvas.height * 1) / 2;
                const distance = Math.random() * Math.min(emissionRadiusX, emissionRadiusY);
                // Apply viewport speed multiplier for consistent visual speed across devices
                const speed = (Math.random() * 0.5 + 0.5) * this.config.speed * (this.config.viewportSpeedMultiplier || 1);
                
                // Stagger particle creation to avoid waves
                const staggerOffset = (index / this.config.particleCount) * 100; // Small stagger for variety
                
                return {
                    x: this.config.centerX + Math.cos(angle) * distance,
                    y: this.config.centerY + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: Math.random() * this.config.size + 0.5,
                    opacity: 1.0,
                    age: 0,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * this.config.rotationSpeed,
                    spriteIndex: Math.floor(Math.random() * this.spriteImageSources.length)
                };
            }
            
            updateParticles() {
                // Update forces first
                this.updateForces();
                
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Apply forces to particle velocity
                    this.forces.forEach(force => {
                        const dx = particle.x - force.x;
                        const dy = particle.y - force.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < this.forceRadius && distance > 0) {
                            // Calculate force strength based on distance and age
                            const normalizedDistance = distance / this.forceRadius;
                            const ageFactor = 1 - (force.age / force.maxAge);
                            const forceMagnitude = this.forceStrength * ageFactor * (1 - normalizedDistance);
                            
                            // Apply repulsive force
                            const forceX = (dx / distance) * forceMagnitude;
                            const forceY = (dy / distance) * forceMagnitude;
                            
                            particle.vx += forceX;
                            particle.vy += forceY;
                        }
                    });
                    
                    // Update position
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Update rotation
                    particle.rotation += particle.rotationSpeed;
                    
                    // Add slight random drift
                    particle.vx += (Math.random() - 0.5) * 0.02;
                    particle.vy += (Math.random() - 0.5) * 0.02;
                    
                    // Apply slight friction
                    particle.vx *= .9995;
                    particle.vy *= .9995;
                    
                    // Calculate distance from center for fade effect
                    const dx = particle.x - this.config.centerX;
                    const dy = particle.y - this.config.centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Fade out based on distance from center
                    const maxVisibleDistance = this.config.maxDistance * 0.8; // Start fading at 80% of max distance
                    const fadeStart = maxVisibleDistance * 0.6; // Start fading at 60% of max distance
                    
                    if (distance > fadeStart) {
                        const fadeProgress = Math.min(1, (distance - fadeStart) / (maxVisibleDistance - fadeStart));
                        particle.opacity = Math.max(0, 1 - fadeProgress);
                    } else {
                        particle.opacity = 1.0;
                    }
                    
                    // Size grows over time (not based on life)
                    particle.age = (particle.age || 0) + 1;
                    const maxAge = 300; // Sprites reach full size after 300 frames
                    const sizeMultiplier = Math.min(1, particle.age / maxAge);
                    particle.currentSize = particle.size * sizeMultiplier;
                    
                    // Remove particles that are completely outside viewport
                    const margin = 100; // Extra margin to ensure smooth removal
                    if (particle.x < -margin || 
                        particle.x > this.canvas.width + margin || 
                        particle.y < -margin || 
                        particle.y > this.canvas.height + margin ||
                        distance > this.config.maxDistance * 1.2) { // Remove at 120% of max distance
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            drawParticles() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply zoom transformation
                this.ctx.save();
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(this.config.zoom, this.config.zoom);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                
                // Draw particles
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.opacity;
                    
                    // Move to particle position and rotate
                    this.ctx.translate(particle.x, particle.y);
                    this.ctx.rotate(particle.rotation);
                    
                    // Draw sprite if loaded, otherwise draw a fallback circle
                    const spriteImage = this.spriteImages[particle.spriteIndex];
                    if (spriteImage && spriteImage.complete) {
                        const spriteSize = particle.currentSize * this.config.spriteSize;
                        this.ctx.drawImage(
                            spriteImage,
                            -spriteSize / 2, -spriteSize / 2,
                            spriteSize, spriteSize
                        );
                    } else {
                        // Fallback: draw a colored circle
                        this.ctx.fillStyle = `hsl(${200 + particle.life * 60}, 80%, ${60 + particle.life * 30}%)`;
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, particle.currentSize * 3, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
                
                this.ctx.restore(); // Restore zoom transformation
            }
            
            animate() {
                if (this.isAnimating) {
                    this.updateParticles();
                    this.drawParticles();
                }
                this.animationId = requestAnimationFrame(() => this.animate());
            }
            
            toggleAnimation() {
                this.isAnimating = !this.isAnimating;
            }
            
            reset() {
                this.createParticles();
            }
            
            // Add a force at the specified position
            addForce(x, y) {
                // Transform click coordinates to match particle coordinate system
                // Reverse the zoom transformation applied in drawParticles
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const transformedX = (x - centerX) / this.config.zoom + centerX;
                const transformedY = (y - centerY) / this.config.zoom + centerY;
                
                console.log('ParticleSpriteSystem: Adding force:', x, y, '-> transformed:', transformedX, transformedY, 'Current forces:', this.forces.length);
                this.forces.push({
                    x: transformedX,
                    y: transformedY,
                    age: 0,
                    maxAge: this.forceDuration
                });
                console.log('ParticleSpriteSystem: Force added. Total forces:', this.forces.length);
            }
            
            // Update forces and remove expired ones
            updateForces() {
                for (let i = this.forces.length - 1; i >= 0; i--) {
                    const force = this.forces[i];
                    force.age++;
                    
                    if (force.age >= force.maxAge) {
                        this.forces.splice(i, 1);
                    }
                }
            }
        }

        const canvases = document.querySelectorAll('canvas.particle')
        const sprites = document.querySelectorAll('canvas.sprite')
        
        // Store particle system instances for force interaction
        const particleSystems = [];
        const spriteSystems = [];
        
        canvases.forEach(canvasElement => {
            particleSystems.push(new ParticleSystem(canvasElement))
        })
        sprites.forEach(canvasElement => {
            spriteSystems.push(new ParticleSpriteSystem(canvasElement))
        })
        
        // Add click/tap event listeners to create forces
        function handleClickOrTap(event) {
            const x = event.clientX || (event.touches && event.touches[0].clientX);
            const y = event.clientY || (event.touches && event.touches[0].clientY);
            
            console.log('Click/Tap at:', x, y, 'Event type:', event.type);
            
            // Add force to all particle systems
            particleSystems.forEach((system, index) => {
                console.log(`Adding force to particle system ${index}:`, x, y);
                system.addForce(x, y);
            });
            spriteSystems.forEach((system, index) => {
                console.log(`Adding force to sprite system ${index}:`, x, y);
                system.addForce(x, y);
            });
        }
        
        // Add event listeners for both click and touch
        document.addEventListener('click', handleClickOrTap);
        document.addEventListener('touchstart', handleClickOrTap);

        // Standalone parallax function
        function createParallaxSystem(elements, options = {}) {
            const multiplier = .05
            const {
                intensity = 1,
                disabled = isTouchDevice(),
                scale = 1,
                centerX = window.innerWidth / 2,
                centerY = window.innerHeight / 2
            } = options;

            if (disabled) return null;

            const handleMouseMove = (e) => {
                const mouseOffsetX = e.clientX - centerX;
                const mouseOffsetY = e.clientY - centerY;
                
                const parallaxX = mouseOffsetX * intensity * multiplier;
                const parallaxY = mouseOffsetY * intensity * multiplier;
                
                elements.forEach(element => {
                    if (element && element.style) {
                        element.style.transform = `scale(${(104 + intensity*2)/100}) translate(${parallaxX}px, ${parallaxY}px)`;
                    }
                });
            };

            document.addEventListener('mousemove', handleMouseMove);
            
            // Return cleanup function
            return () => {
                document.removeEventListener('mousemove', handleMouseMove);
            };
        }

        // Unified parallax system that queries elements by data-parallax attribute
        class UnifiedParallaxSystem {
            constructor() {
                this.cleanupFunctions = [];
                this.setupParallax();
            }
            
            setupParallax() {
                // Query all elements with data-parallax attribute
                const elementsWithParallax = document.querySelectorAll('[data-parallax]');
                
                // Group elements by their parallax intensity
                const intensityGroups = {};
                
                elementsWithParallax.forEach(element => {
                    const intensity = parseFloat(element.dataset.parallax);
                    if (!isNaN(intensity) && intensity > 0) {
                        if (!intensityGroups[intensity]) {
                            intensityGroups[intensity] = [];
                        }
                        intensityGroups[intensity].push(element);
                    }
                });
                
                // Create parallax systems for each intensity group
                Object.keys(intensityGroups).forEach(intensity => {
                    const elements = intensityGroups[intensity];
                    const numIntensity = parseFloat(intensity);
                    
                    // Determine if this group needs special handling (e.g., video with scale)
                    const hasVideo = elements.some(el => el.tagName === 'VIDEO');
                    const scale = hasVideo ? 1.05 : 1; // Video gets scale for fullscreen movement
                    
                    const cleanup = createParallaxSystem(elements, {
                        intensity: numIntensity,
                        scale: scale,
                        disabled: isTouchDevice()
                    });
                    
                    if (cleanup) {
                        this.cleanupFunctions.push(cleanup);
                    }
                });
            }
            
            // Cleanup method to remove event listeners
            destroy() {
                this.cleanupFunctions.forEach(cleanup => cleanup());
                this.cleanupFunctions = [];
            }
        }
        
        // Initialize unified parallax system
        new UnifiedParallaxSystem();
        
    </script>
</body>
</html>
